---
alwaysApply: false
---

# Dify API 集成开发规范

## 核心原则：关注点分离

Dify API集成分为三层架构：

### 1. 代理层 (Backend Proxy)
- **位置**: `app/api/dify/[appId]/[...slug]/route.ts`
- **职责**: 认证、请求转发、响应代理
- **原则**: 不关心业务逻辑，只负责安全转发

### 2. 服务层 (Service Layer)
- **位置**: `lib/services/dify/*.ts` (按功能域划分)
- **职责**: 业务逻辑、API调用、数据处理
- **原则**: 不关心认证细节，只调用代理层

### 3. 类型层 (Type Definitions)
- **位置**: `lib/services/dify/types.ts`
- **职责**: 统一定义所有TypeScript数据结构
- **原则**: 作为服务层的数据契约

## 新增Dify API的开发流程

### 步骤1: 定义类型
在 `types.ts` 中添加请求和响应的TypeScript接口

### 步骤2: 选择/创建服务文件
根据功能域选择合适的服务文件，或创建新的服务文件

### 步骤3: 实现服务函数
```typescript
export async function newDifyFunction(
  appId: string,
  payload: RequestType
): Promise<ResponseType> {
  const slug = 'api/path';
  const apiUrl = `/api/dify/${appId}/${slug}`;
  
  const response = await fetch(apiUrl, {
    method: 'POST',
    body: JSON.stringify(payload),
    headers: { 'Content-Type': 'application/json' }
  });
  
  if (!response.ok) {
    throw new Error(`API调用失败: ${response.statusText}`);
  }
  
  return response.json();
}
```

### 步骤4: 前端使用
```typescript
import { newDifyFunction } from '@lib/services/dify/service-name';

// 在组件或Hook中使用
const result = await newDifyFunction(appId, params);
```

## 核心优势

- **清晰性**: 职责分离，代码易理解
- **模块化**: 按功能域划分，积木式组合
- **低耦合**: 各层独立，变更影响最小
- **易维护**: 问题定位准确，配置修改集中
- **可扩展**: 新功能开发流程标准化

## 开发要求

在开发Dify相关功能时，请严格遵循此标准。这确保了：

- **维护性**: 更容易定位和修复问题，修改配置（如API Key）只需要在一个地方（代理层）修改
- **扩展性**: 添加新功能只需要按照流程创建新的类型和服务函数，对现有代码影响最小
# Dify API 集成开发规范

## 核心原则：关注点分离

Dify API集成分为三层架构：

### 1. 代理层 (Backend Proxy)
- **位置**: `app/api/dify/[appId]/[...slug]/route.ts`
- **职责**: 认证、请求转发、响应代理
- **原则**: 不关心业务逻辑，只负责安全转发

### 2. 服务层 (Service Layer)
- **位置**: `lib/services/dify/*.ts` (按功能域划分)
- **职责**: 业务逻辑、API调用、数据处理
- **原则**: 不关心认证细节，只调用代理层

### 3. 类型层 (Type Definitions)
- **位置**: `lib/services/dify/types.ts`
- **职责**: 统一定义所有TypeScript数据结构
- **原则**: 作为服务层的数据契约

## 新增Dify API的开发流程

### 步骤1: 定义类型
在 `types.ts` 中添加请求和响应的TypeScript接口

### 步骤2: 选择/创建服务文件
根据功能域选择合适的服务文件，或创建新的服务文件

### 步骤3: 实现服务函数
```typescript
export async function newDifyFunction(
  appId: string,
  payload: RequestType
): Promise<ResponseType> {
  const slug = 'api/path';
  const apiUrl = `/api/dify/${appId}/${slug}`;
  
  const response = await fetch(apiUrl, {
    method: 'POST',
    body: JSON.stringify(payload),
    headers: { 'Content-Type': 'application/json' }
  });
  
  if (!response.ok) {
    throw new Error(`API调用失败: ${response.statusText}`);
  }
  
  return response.json();
}
```

### 步骤4: 前端使用
```typescript
import { newDifyFunction } from '@lib/services/dify/service-name';

// 在组件或Hook中使用
const result = await newDifyFunction(appId, params);
```

## 核心优势

- **清晰性**: 职责分离，代码易理解
- **模块化**: 按功能域划分，积木式组合
- **低耦合**: 各层独立，变更影响最小
- **易维护**: 问题定位准确，配置修改集中
- **可扩展**: 新功能开发流程标准化

## 开发要求

在开发Dify相关功能时，请严格遵循此标准。这确保了：

- **维护性**: 更容易定位和修复问题，修改配置（如API Key）只需要在一个地方（代理层）修改
- **扩展性**: 添加新功能只需要按照流程创建新的类型和服务函数，对现有代码影响最小
